import numpy as np
from cellpose import utils, io
import glob
import os
import pandas as pd
import math
from skimage import io as sk_io, color
import re
import pickle


import sys
import os
import Format_1 as F_1

import warnings
warnings.simplefilter(action='ignore', category=FutureWarning)






@F_1.ParameterLog(max_size = 1024 * 10, log_level = 0) # 0.1KB per smallest unit in return (8 bits per ASCII character)
def CP_extract_1(
    # input
    input_dir,

    # extraction parameters
    CP_model_type = None, diameter_training_px = None,
    save_flows = 0, # 0: don't save flows, 1: save flows

    # output and logging 
    CP_extract_log_level = 0,
    output_dir_manual = "", output_dir_comment = "",
    ):
    
    """
    Extracts segmentation data and calculates pixel-based metrics, saving the
    results to a pandas DataFrame.

    This function processes Cellpose segmentation output files (`_seg.npy`)
    located in the `input_dir`. It loads corresponding image data, VisIt projection
    data, and Cellpose settings. It then calculates various pixel-based metrics
    like cell counts, diameters (mean, median, distribution), and areas.
    Finally, all extracted and calculated data is compiled into a pandas DataFrame
    named 'extracted_DataFrame' and saved in CSV, Pickle, and Excel formats
    in the specified output directory. This DataFrame serves as input for the
    `CP_dimentionalise_1` function.

    Parameters
    ----------
    input_dir : str
        Path to the directory containing the Cellpose segmentation output files
        (`*_seg.npy`) and the `CP_settings.pkl` file generated by `CP_segment_1`.
    CP_model_type : str or None, optional
        Specifies the Cellpose model type used for segmentation ('cyto', 'cyto2',
        'cyto3', 'nuclei', or a custom path to the model). Used to determine `diameter_training_px`
        if not provided explicitly. Defaults to None (will then be read from the
        settings file).
    diameter_training_px : float or None, optional
        The diameter (in pixels) that was used during the training of the Cellpose model.
        Required if a custom model was used and this information is not in the
        settings file or cannot be inferred from `CP_model_type`. Defaults to None.
    CP_extract_log_level : int, optional
        Controls the verbosity of logging messages printed to the console.
        0: Minimal logging.
        1: Basic loading and processing steps.
        Defaults to 0.
    output_dir_manual : str, optional
        If provided, specifies the exact output directory path. Overrides the
        default naming convention managed by `Format_1.F_out_dir`. Defaults to "".
    output_dir_comment : str, optional
        A comment to append to the default output directory name if `output_dir_manual`
        is not provided. Defaults to "".

    Returns
    -------
    output_dir : str
        The path to the directory where the output DataFrame files
        (`extracted_DataFrame.csv`, `extracted_DataFrame.pkl`,
        `extracted_DataFrame.xlsx`) and logs (`_log.json`) are saved.
        This is always the first return value as required by Format_1.

    Notes
    -----
    - This function relies on `Format_1.py` for output directory creation (`F_out_dir`)
      and parameter logging (`@F_1.ParameterLog`).
    - Assumes the input directory (`input_dir`) is a subdirectory of the directory
      containing the original images (`.png`) and the VisIt data (`Visit_projector_1_data.pkl`).
    """
    #################################################### I/O
    output_dir = F_1.F_out_dir(input_dir, __file__, output_dir_comment = output_dir_comment, output_dir_manual = output_dir_manual) # Format_1 required definition of output directory



    #################################################### Load and extract data
    print(f"\n Loading data \n")


    # Load VisIt data (VisIt data not images)
    VisIt_output_dir = os.path.abspath(os.path.join(input_dir, os.pardir))
    VisIt_data_dir = f"{VisIt_output_dir}\Visit_projector_1_data.pkl"
    VisIt_data_df = pd.read_pickle(VisIt_data_dir)
    print(f"VisIt_output_dir: {VisIt_output_dir}") if CP_extract_log_level >= 2 else None
    print(f"VisIt_data_dir: {VisIt_data_dir}") if CP_extract_log_level >= 2 else None
    print(f"VisIt_data: {VisIt_data_df}") if CP_extract_log_level >= 2 else None

    # Load image data (could be VisIt output images)
    image_input_dir = os.path.dirname(input_dir) # one folder above
    image_files = glob.glob(os.path.join(image_input_dir, '*.png'))
    all_images = []
    all_grayscale_images = []
    image_number = []
    for image_file in image_files:
        # Load the image (RGBA)
        rgbA_image_px2 = sk_io.imread(image_file)
        
        # Convert to grayscale by ignoring the alpha channel
        grayscale_image = color.rgb2gray(rgbA_image_px2[..., :3])
        
        # Append both RGBA and grayscale images as a tuple
        all_images.append(rgbA_image_px2)
        all_grayscale_images.append(grayscale_image)

        # Extract the numeric part from the filename
        match = re.search(r'_(\d+)\.png$', os.path.basename(image_file))
        if match:
            image_number.append(int(match.group(1)))
        else:
            image_number.append(None)  # Handle cases where no number is found

    N_images = len(all_images)
    print(f"Loaded {N_images} images \n") if CP_extract_log_level >= 1 else None

    # Load Cellpose segmentation data
    seg_location = input_dir
    seg_files = glob.glob(os.path.join(seg_location, '*_seg.npy'))
    all_segs = []
    seg_filenames = []
    for seg_file in seg_files:
        seg = np.load(seg_file, allow_pickle=True).item()
        all_segs.append(seg)
        filename = os.path.basename(seg_file).replace('_seg.npy', '')
        seg_filenames.append(filename)
        #print(f"Adding file to all_segs: {seg_file}")  # Print the file being added
    N_seg = len(all_segs)
    print(f"Loaded {N_seg} seg files") if CP_extract_log_level >= 1 else None
    if N_images != N_seg:
        raise ValueError("Number of images and segmentations do not match")


    # Load Cellpose model settings
    CP_settings_file = f"{input_dir}/CP_settings.pkl"
    with open(CP_settings_file, "rb") as file:
        CP_settings = pickle.load(file)
        CP_model_type = CP_settings["CP_model_type"].iloc[0]
        CP_model_path = CP_settings["CP_model_path"].iloc[0]
        CP_model_for_diameter_estimate = CP_settings["CP_model_for_diameter_estimate"].iloc[0]
        gpu = CP_settings["gpu"].iloc[0]
        diameter_estimate_guess_px = CP_settings["diameter_estimate_guess_px"].iloc[0]
        CP_segment_output_dir_comment = CP_settings["CP_segment_output_dir_comment"].iloc[0]
        flow_threshold = CP_settings["flow_threshold"].iloc[0]
        cellprob_threshold = CP_settings["cellprob_threshold"].iloc[0]
        resample = CP_settings["resample"].iloc[0]
        niter = CP_settings["niter"].iloc[0]
    print(f"CP_settings_file: {CP_settings_file}") if CP_extract_log_level >= 2 else None
    print(f"CP_settings: {CP_settings}") if CP_extract_log_level >= 2 else None



    #################################################### Extract and Tabularize data

    print(f"\n Extracting data \n")

    # Initialize DataFrame
    extracted_df_columns = [
        'image_file_name', 'image_file_path', 'image_number', 'image_Nx_px', 'image_Ny_px',
        'seg_file_name', 'seg_file_path', 'ismanual', 'CP_model_path', 'CP_model_type', 'channels',
        'flows0', 'flows1', 'flows2', 'flows3', 'flows4',
        'diameter_estimate_used_px', 'diameter_training_px',
        'diameter_mean_px', 'diameter_median_px', 'diameter_distribution_px', 'outlines', 'masks', 'N_cells',
        'A_image_px2', 'A_empty_px2', 'A_SF_px2', 'Ar_px2_SFperimage', 'D_SF_px', 'R_SF_px',
        'A_CP_mask_px', 'Ar_px2_CP_maskperImage', 'Ar_px2_CP_maskperSF',
        # Added columns from CP_settings that were previously read but not explicitly added here
        'gpu', 'diameter_estimate_guess_px', 'CP_segment_output_dir_comment', 'flow_threshold',
        'cellprob_threshold', 'resample', 'niter'
    ]
    extracted_df = pd.DataFrame(columns=extracted_df_columns)

    # Preallocate columns to avoid growing the DataFrame dynamically
    for col in extracted_df_columns:
        extracted_df[col] = np.nan  # Initialize all columns with NaN

    # Explicitly set multiple columns to 'object' to allow lists or complex data types
    columns_with_lists = [
        'ismanual', 'flows0', 'flows1', 'flows2', 'flows3', 'flows4', 'channels',
        'outlines', 'masks', 'diameter_distribution_px',
    ]
    for column in columns_with_lists:
        # Check if column exists before setting dtype, as some might be added later
        if column in extracted_df.columns:
            extracted_df[column] = pd.Series(dtype="object")

    # Ensure all columns intended to be object are explicitly set, even if pre-allocated differently
    for col in columns_with_lists:
        if col in extracted_df.columns:
            extracted_df[col] = extracted_df[col].astype('object')


    ## Extract data by looping through each image and its segmentation for better controll (computationally more expensive but its ok)
    for i in range(N_images):
        image_i = all_images[i]
        grayscale_image_i = all_grayscale_images[i]
        seg_i = all_segs[i]

        # read seg
        masks_i = seg_i['masks']
        outlines_i = seg_i['outlines']
        if save_flows == 1: # to save storage space don't save flows values.
            flow_i = seg_i['flows']
        else:
            flow_i = [None] * 5
        diameter_estimate_used_px_i = seg_i["diameter"]
        channels = seg_i["chan_choose"]
        ismanual = seg_i['ismanual']
        seg_image_filename = seg_i["filename"] # gives seg filename though it shoud give images file name. weird...

        # training diameter. Thats the diameter of cells used for training the Cellpose U-net. 
        if diameter_training_px is None:
            if CP_model_type in ["cyto", "cyto2", "cyto3"]:
                diameter_training_px = 30
            elif CP_model_type == "nuclei":
                diameter_training_px = 17
            elif CP_model_type is None:
                print("NB: diameter_training_px can't be deduced. Please provide it explicitly or specify a standard CP_model_type ('cyto', 'cyto2', 'cyto3', or 'nuclei') as an argument to CP_extract_1.")

        # extract diameter tuple and from its mean and complete distribution
        diameters_tuple_i = utils.diameters(masks_i)
        diameter_median_px_i = diameters_tuple_i[0]
        diameter_array_px_i = diameters_tuple_i[1]
        diameter_mean_px_i = np.mean(diameter_array_px_i)

        # Calculate the relative frequency of each diameter in diameter_array_px_i
        diameters_unique, counts_diameters = np.unique(diameter_array_px_i, return_counts=True)
        diameters_total = diameter_array_px_i.size
        diameters_relative_frequencies = counts_diameters / diameters_total

        # CP effectiveness measures
        N_cells_i = np.max(masks_i)
        image_Nx_px = image_i.shape[0]
        image_Ny_px = image_i.shape[1]
        A_image_px2 = image_Nx_px * image_Ny_px
        A_empty_px2 = np.sum(grayscale_image_i == 1)
        A_SF_px2 = A_image_px2 - A_empty_px2
        Ar_px2_SFperimage = A_SF_px2 / A_image_px2
        D_SF_px = math.sqrt(A_SF_px2 * 4 / math.pi)
        R_SF_px = D_SF_px / 2

        A_CP_mask_px = np.count_nonzero(masks_i != 0)
        Ar_px2_CP_maskperImage = A_CP_mask_px / A_image_px2
        Ar_px2_CP_maskperSF = A_CP_mask_px / A_SF_px2
        

        ### Fill a DataFrame row
        # Data from VisIt
        extracted_df.at[i, 'Plot_VisIt']                = VisIt_data_df.at[i, 'Plot_VisIt']
        extracted_df.at[i, 'Image_filename_VisIt']      = VisIt_data_df.at[i, 'Image_filename_VisIt']
        extracted_df.at[i, 'State_range_VisIt']         = VisIt_data_df.at[i, 'State_range_VisIt']
        extracted_df.at[i, 'Time_VisIt']                = VisIt_data_df.at[i, 'Time_VisIt']
        extracted_df.at[i, 'R_SF_Average_VisIt']        = VisIt_data_df.at[i, 'R_SF_Average_VisIt']
        # Data from Images
        extracted_df.at[i, 'image_file_name'] = os.path.basename(image_files[i]) # Store only filename
        extracted_df.at[i, 'image_file_path'] = image_files[i]
        extracted_df.at[i, 'image_number'] = image_number[i]
        extracted_df.at[i, 'image_Nx_px'] = image_Nx_px
        extracted_df.at[i, 'image_Ny_px'] = image_Ny_px
        # Data from Cellpose settings
        extracted_df.at[i, 'CP_model_path'] = CP_model_path 
        extracted_df.at[i, 'CP_model_type'] = CP_model_type
        extracted_df.at[i, 'CP_model_for_diameter_estimate'] = CP_model_for_diameter_estimate
        extracted_df.at[i, 'channels'] = channels
        extracted_df.at[i, 'gpu'] = gpu
        extracted_df.at[i, 'diameter_estimate_guess_px'] = diameter_estimate_guess_px
        extracted_df.at[i, 'CP_segment_output_dir_comment'] = CP_segment_output_dir_comment
        extracted_df.at[i, 'flow_threshold'] = flow_threshold
        extracted_df.at[i, 'cellprob_threshold'] = cellprob_threshold
        extracted_df.at[i, 'resample'] = resample
        extracted_df.at[i, 'niter'] = niter
        # Data from seg file
        extracted_df.at[i, 'seg_file_name'] = seg_filenames[i]
        extracted_df.at[i, 'seg_file_path'] = seg_files[i] # Store full path to seg file
        extracted_df.at[i, 'ismanual'] = ismanual
        extracted_df.at[i, 'flows0'] = flow_i[0]
        extracted_df.at[i, 'flows1'] = flow_i[1]
        extracted_df.at[i, 'flows2'] = flow_i[2]
        extracted_df.at[i, 'flows3'] = flow_i[3]
        extracted_df.at[i, 'flows4'] = flow_i[4]
        extracted_df.at[i, 'outlines'] = outlines_i
        extracted_df.at[i, 'masks'] = masks_i
        extracted_df.at[i, 'diameter_estimate_used_px'] = diameter_estimate_used_px_i
        # Data calculated
        extracted_df.at[i, 'diameter_training_px'] = diameter_training_px
        extracted_df.at[i, 'diameter_mean_px'] = diameter_mean_px_i
        extracted_df.at[i, 'diameter_median_px'] = diameter_median_px_i
        extracted_df.at[i, 'diameter_distribution_px'] = diameter_array_px_i
        extracted_df.at[i, 'N_cells'] = N_cells_i
        extracted_df.at[i, 'A_image_px2'] = A_image_px2
        extracted_df.at[i, 'A_empty_px2'] = A_empty_px2
        extracted_df.at[i, 'A_SF_px2'] = A_SF_px2
        extracted_df.at[i, 'Ar_px2_SFperimage'] = Ar_px2_SFperimage
        extracted_df.at[i, 'D_SF_px'] = D_SF_px
        extracted_df.at[i, 'R_SF_px'] = R_SF_px
        extracted_df.at[i, 'A_CP_mask_px'] = A_CP_mask_px
        extracted_df.at[i, 'Ar_px2_CP_maskperImage'] = Ar_px2_CP_maskperImage
        extracted_df.at[i, 'Ar_px2_CP_maskperSF'] = Ar_px2_CP_maskperSF


    # Clean diameter_distribution_px after the loop
    extracted_df['diameter_distribution_px'] = extracted_df['diameter_distribution_px'].apply(
        lambda x: np.array([x]) if isinstance(x, np.ndarray) and x.ndim == 0 else x
    )

    # Print columns that have None values
    none_columns = extracted_df.columns[extracted_df.isnull().any()].tolist()
    print(f"NB: Columns with None/NaN values after extraction: {none_columns}") if CP_extract_log_level >= 1 else None


    #################################################### Save Data

    print(f"\n Saving data \n")

    ### Save Extracted DataFrame
    csv_filename = 'extracted_DataFrame.csv'
    extracted_df.to_csv(os.path.join(output_dir, csv_filename), sep='\t', index=False)
    print(f"Saved extracted DataFrame to {csv_filename}") if CP_extract_log_level >= 1 else None

    # Save DataFrame to Pickle (Primary input for CP_dimentionalise_1)
    pickle_filename = 'extracted_DataFrame.pkl'
    extracted_df.to_pickle(os.path.join(output_dir, pickle_filename))
    print(f"Saved extracted DataFrame to {pickle_filename}") if CP_extract_log_level >= 1 else None

    # # Save DataFrame to Excel (useful for manual inspection)
    # excel_filename = 'extracted_DataFrame.xlsx'
    # try:
    #     # Convert complex objects like numpy arrays to strings for Excel compatibility
    #     df_for_excel = extracted_df.copy()
    #     for col in df_for_excel.columns:
    #         print(f"Saving to excel: Checking column: {col}") if CP_extract_log_level >= 2 else None
    #         if df_for_excel[col].apply(lambda x: isinstance(x, np.ndarray)).any():
    #             df_for_excel[col] = df_for_excel[col].apply(lambda x: str(x.tolist()) if isinstance(x, np.ndarray) else x) # Convert arrays to string representation of list
    #     df_for_excel.to_excel(os.path.join(output_dir, excel_filename), index=False)
    #     print(f"Saved extracted DataFrame to {excel_filename}") if CP_extract_log_level >= 1 else None

    # except Exception as e:
    #     print(f"Warning: Could not save extracted data to Excel format. Error: {e}")
    #     print("Excel format might not support complex data types like numpy arrays stored in the DataFrame.")



    #################################################### return
    return output_dir # Format_1 requires output_dir as first return