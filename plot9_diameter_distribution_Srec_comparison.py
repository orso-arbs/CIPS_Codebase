import numpy as np
import matplotlib.pyplot as plt
import warnings
import glob
import os
import pandas as pd
import matplotlib.gridspec as gridspec
import skimage.io as sk_io
from matplotlib.colors import Normalize
import matplotlib as mpl
import Format_1 as F_1
import video_maker_1 as vm1
import matplotlib.cm as cm  # Add this import

@F_1.ParameterLog(max_size=1024 * 10)  # 10KB
def plot9_diameter_distribution_Srec_comparison(
    # Input parameters
    input_dir,  # Format_1 requires input_dir
    SRec_df=None,  # if None a .pkl file has to be in the input_dir
    
    # Output and display parameters
    output_dir_manual="", 
    output_dir_comment="",
    save_svg=True,      # Save plots as SVG
    save_png=True,      # Save plots as PNG
    show_plots=False,   # Display plots during execution
    create_video=False,  # Create a video from the plot images
    video_fps=5,        # Frames per second for the video
    
    # Plot appearance parameters
    show_image_inset=True,        # Show flame image inset
    image_inset_size=0.4,        # Size of image inset as fraction of plot
    image_margin=0.1,           # Margin between image inset and plot box edges
    zoom_scale=1.3,              # Scale factor for zooming in on the spherical flame
    mask_alpha=0.5,               # Transparency of masks in the inset
    show_centroids=True,          # Show cell centroids in the inset
    bin_count=50,                 # Number of histogram bins
    grid_alpha=0.2,               # Transparency of grid
    Plot_log_level=1,             # Logging verbosity
    x_axis_extension=1.1,         # Factor to extend x-axis beyond min/max area
    y_axis_extension=1.1,         # Factor to extend y-axis beyond max frequency
    x_axis_limit=None,            # Manual x-axis limit (overrides extension factor)
    y_axis_limit=None,            # Manual y-axis limit (overrides extension factor)
    Frequency_percent_of_max=True,  # If True, normalize frequency as percentage of max
):
    """
    Creates comparative histograms of original vs spherically reconstructed cell areas.
    
    This function processes spherical reconstruction data, creating histograms that compare
    the diameter distribution before and after spherical reconstruction for each image.
    It can optionally show an inset image of the flame with masks and centroids,
    and can compile the individual plots into a video.
    
    Parameters
    ----------
    input_dir : str
        Path to the directory containing the SRec_DataFrame.pkl file
        with data generated by Spherical_Reconstruction_1.
    SRec_df : pandas.DataFrame or None, optional
        A pre-loaded DataFrame containing the spherical reconstruction data.
        If provided, it overrides loading from the .pkl file in input_dir.
        If None, the function attempts to load SRec_DataFrame.pkl from input_dir.
        Defaults to None.
    output_dir_manual : str, optional
        If provided, specifies the exact output directory path for the plots/video.
        Overrides the default naming convention. Defaults to "".
    output_dir_comment : str, optional
        A comment to append to the default output directory name. Defaults to "".
    save_svg : bool, optional
        If True, saves plots in SVG format. Defaults to True.
    save_png : bool, optional
        If True, saves plots in PNG format. Defaults to True.
    show_plots : bool, optional
        If True, displays plots during execution. Defaults to False.
    create_video : bool, optional
        If True, creates a video from the generated plot images using video_maker_1.
        Defaults to True.
    video_fps : int, optional
        Frames per second for the video if create_video is True. Defaults to 5.
    show_image_inset : bool, optional
        If True, shows an inset of the flame image with masks. Defaults to True.
    image_inset_size : float, optional
        Size of the image inset as a fraction of the plot. Defaults to 0.35.
    image_margin : float, optional
        Margin between the image inset and the plot box edges, as a fraction of the plot size. Defaults to 0.05.
    zoom_scale : float, optional
        Scale factor for zooming in on the spherical flame in the image inset. Defaults to 1.5.
    mask_alpha : float, optional
        Transparency of masks in the inset image. Defaults to 0.3.
    show_centroids : bool, optional
        If True, shows cell centroids in the image inset. Defaults to True.
    bin_count : int, optional
        Number of bins for the diameter distribution histogram. Defaults to 30.
    grid_alpha : float, optional
        Transparency of the grid in the plot. Defaults to 0.2.
    Plot_log_level : int, optional
        Controls the verbosity of logging. Defaults to 1.
    x_axis_extension : float, optional
        Factor to extend the x-axis range beyond the min and max area values.
        Defaults to 1.1 (10% extension).
    y_axis_extension : float, optional
        Factor to extend the y-axis range beyond the max frequency value.
        Defaults to 1.1 (10% extension).
    x_axis_limit : tuple of float, optional
        Manual limits for the x-axis as (min, max). Overrides x_axis_extension if provided.
    y_axis_limit : tuple of float, optional
        Manual limits for the y-axis as (min, max). Overrides y_axis_extension if provided.
    Frequency_percent_of_max : bool, optional
        If True, normalizes frequency as percentage of maximum frequency across all images.
        Default is False.
    
    Returns
    -------
    output_dir : str
        The path to the directory where the output plots and folders are saved.
    
    Notes
    -----
    The function creates separate directories for PNG and SVG outputs within the main output directory.
    It compares original cell diameter distributions with those after spherical reconstruction.
    """
    # Suppress MatplotlibDeprecationWarning if log level is not >= 2
    if Plot_log_level < 2:
        warnings.filterwarnings('ignore', category=mpl.MatplotlibDeprecationWarning)

    #################################################### I/O
    output_dir = F_1.F_out_dir(input_dir, __file__, output_dir_comment=output_dir_comment, 
                            output_dir_manual=output_dir_manual)  # Format_1 required definition of output directory

    # Set normalization option
    normalize_to_percent = True  # Move this declaration up here

    # Create subdirectories for PNG and SVG outputs if needed
    if save_png:
        png_dir = os.path.join(output_dir, "png_plots")
        os.makedirs(png_dir, exist_ok=True)
        print(f"PNG plots will be saved to: {png_dir}") if Plot_log_level >= 1 else None
    
    if save_svg:
        svg_dir = os.path.join(output_dir, "svg_plots")
        os.makedirs(svg_dir, exist_ok=True)
        print(f"SVG plots will be saved to: {svg_dir}") if Plot_log_level >= 1 else None

    #################################################### Load data
    if SRec_df is None:
        # Look for SRec_DataFrame.pkl file
        srec_file_path = os.path.join(input_dir, "SRec_DataFrame.pkl")
        if not os.path.exists(srec_file_path):
            # If not found, try to find any .pkl file
            pkl_files = glob.glob(os.path.join(input_dir, "*.pkl"))
            if pkl_files:
                srec_file_path = pkl_files[0]
            else:
                raise FileNotFoundError(f"No SRec_DataFrame.pkl or other .pkl files found in {input_dir}")
        
        print(f"Loading spherical reconstruction data from: {srec_file_path}") if Plot_log_level >= 1 else None
        SRec_df = pd.read_pickle(srec_file_path)
    else:
        print("Using provided SRec DataFrame") if Plot_log_level >= 1 else None

    # Verify the DataFrame has the required columns
    required_columns = ['d_cell_distribution_nonDim', 'd_cell_SRec_distribution_nonDim', 
                         'image_file_path', 'masks', 'centroid_x_distribution_px', 
                         'centroid_y_distribution_px', 'A_cell_distribution_nonDim2', 
                         'A_cell_SRec_distribution_nonDim2']
    
    for col in required_columns:
        if col not in SRec_df.columns:
            print(f"Warning: Column '{col}' not found in the DataFrame. Some functionality may be limited.")

    #################################################### Plotting
    # Number of rows in the DataFrame
    N_images = len(SRec_df)

    # Find the maximum area value and determine bin edges
    all_areas_2d = np.concatenate([areas for areas in SRec_df['A_cell_distribution_nonDim2'] 
                                  if areas is not None and len(areas) > 0])
    all_areas_3d = np.concatenate([areas for areas in SRec_df['A_cell_SRec_distribution_nonDim2'] 
                                  if areas is not None and len(areas) > 0])
    
    max_area = max(np.max(all_areas_2d), np.max(all_areas_3d)) if len(all_areas_2d) > 0 and len(all_areas_3d) > 0 else 1
    min_area = min(np.min(all_areas_2d), np.min(all_areas_3d)) if len(all_areas_2d) > 0 and len(all_areas_3d) > 0 else 0
    
    # Create bins for histograms
    bins = np.linspace(min_area, max_area, bin_count + 1)
    if Plot_log_level >= 2:
        print(f"\nBin edges: {bins}")
        print(f"Number of bins: {len(bins)-1}")
    
    # Calculate the maximum frequency across all histograms to normalize y-axis
    max_frequency_2d = 0
    max_frequency_3d = 0
    for i in range(N_images):
        areas_2d = SRec_df.iloc[i]['A_cell_distribution_nonDim2']
        areas_3d = SRec_df.iloc[i]['A_cell_SRec_distribution_nonDim2']
        
        if Plot_log_level >= 2:
            print(f"\nProcessing image {i+1}:")
            print(f"2D areas shape: {areas_2d.shape if areas_2d is not None else None}")
            print(f"3D areas shape: {areas_3d.shape if areas_3d is not None else None}")
        
        # Process 2D areas
        if areas_2d is not None and len(areas_2d) > 0:
            hist_2d, _ = np.histogram(areas_2d, bins=bins)
            if Plot_log_level >= 2:
                print(f"2D histogram counts: {hist_2d}")
                print(f"2D max count: {np.max(hist_2d)}")
            
            if Frequency_percent_of_max:
                max_frequency_2d = max(max_frequency_2d, np.max(hist_2d))
            else:
                max_frequency_2d = max(max_frequency_2d, np.max(hist_2d))
        
        # Process 3D areas
        if areas_3d is not None and len(areas_3d) > 0:
            hist_3d, _ = np.histogram(areas_3d, bins=bins)
            if Plot_log_level >= 2:
                print(f"3D histogram counts: {hist_3d}")
                print(f"3D max count: {np.max(hist_3d)}")
            
            if Frequency_percent_of_max:
                max_frequency_3d = max(max_frequency_3d, np.max(hist_3d))
            else:
                max_frequency_3d = max(max_frequency_3d, np.max(hist_3d))
    
    # Find the overall maximum for y-axis scaling
    max_frequency = max(max_frequency_2d, max_frequency_3d)
    
    print(f"Processing {N_images} images with area range: {min_area:.2f} to {max_area:.2f}") if Plot_log_level >= 1 else None
    print(f"Maximum frequency - 2D: {max_frequency_2d}, 3D: {max_frequency_3d}") if Plot_log_level >= 1 else None
    
    # Process each image
    print(f"\nPlotting area distributions:")
    for i in range(N_images):
        print(f"\rProcessing image {i+1}/{N_images}", end='', flush=True) if Plot_log_level >= 1 else None
        
        # Create figure
        fig = plt.figure(figsize=(12, 9))
        
        # If showing image inset, use GridSpec for layout
        if show_image_inset:
            gs = gridspec.GridSpec(1, 1, figure=fig)
            ax = fig.add_subplot(gs[0, 0])
            
            # Calculate position for image inset in top right
            inset_width = image_inset_size
            inset_height = image_inset_size
            inset_left = 1 - inset_width - image_margin
            inset_bottom = 1 - inset_height - image_margin
            
            # Create inset axes
            ax_inset = fig.add_axes([inset_left, inset_bottom, inset_width, inset_height])
            
            try:
                image_path = SRec_df.iloc[i]['image_file_path']
                image = sk_io.imread(image_path)
                masks = SRec_df.iloc[i]['masks']
                
                # Calculate zoom region to focus on the spherical flame
                img_height, img_width = image.shape[:2]
                center_x, center_y = img_width // 2, img_height // 2
                D_SF_px = SRec_df.iloc[i]['D_SF_px']
                zoom_half_size = int(D_SF_px * zoom_scale / 2)
                
                # Ensure zoom region is within image bounds
                left = max(0, center_x - zoom_half_size)
                right = min(img_width, center_x + zoom_half_size)
                top = max(0, center_y - zoom_half_size)
                bottom = min(img_height, center_y + zoom_half_size)
                
                # Extract and display the zoomed region
                image_zoomed = image[top:bottom, left:right]
                ax_inset.imshow(image_zoomed)
                
                # Create a masked array for the masks in the zoomed region
                masks_zoomed = masks[top:bottom, left:right]
                masked_data = np.ma.masked_where(masks_zoomed == 0, masks_zoomed % 10)
                
                # Use older syntax for colormap
                cmap = cm.get_cmap('tab10', 10)  # This works in older matplotlib versions
                ax_inset.imshow(masked_data, cmap=cmap, alpha=mask_alpha)

                # Show centroids if requested (adjust coordinates for zoom)
                if show_centroids and 'centroid_x_distribution_px' in SRec_df.columns:
                    centroids_x = SRec_df.iloc[i]['centroid_x_distribution_px']
                    centroids_y = SRec_df.iloc[i]['centroid_y_distribution_px']
                    if len(centroids_x) > 0 and len(centroids_y) > 0:
                        # Adjust centroid coordinates for zoomed view
                        valid_centroids = [(x, y) for x, y in zip(centroids_x, centroids_y)
                                         if left <= x <= right and top <= y <= bottom]
                        if valid_centroids:
                            x_coords, y_coords = zip(*valid_centroids)
                            ax_inset.scatter(
                                [x - left for x in x_coords],
                                [y - top for y in y_coords],
                                c='red', s=10, alpha=0.7
                            )
                
                ax_inset.axis('off')
                
            except Exception as e:
                print(f"\nWarning: Could not display image inset for image {i+1}: {str(e)}") if Plot_log_level >= 1 else None
                ax_inset.remove()
        else:
            ax = fig.add_subplot(111)
        
        # Get the area distributions
        areas_2d = SRec_df.iloc[i]['A_cell_distribution_nonDim2']
        areas_3d = SRec_df.iloc[i]['A_cell_SRec_distribution_nonDim2']
        
        if areas_2d is None or len(areas_2d) == 0:
            print(f"\nWarning: No 2D area data for image {i+1}") if Plot_log_level >= 1 else None
            continue
            
        if areas_3d is None or len(areas_3d) == 0:
            print(f"\nWarning: No 3D area data for image {i+1}") if Plot_log_level >= 1 else None
            continue
        
        # Get diameters if available for the legend
        try:
            d_2d = np.mean(SRec_df.iloc[i]['d_cell_distribution_nonDim'])
            d_3d = np.mean(SRec_df.iloc[i]['d_cell_SRec_distribution_nonDim'])
            diameter_str = f"2D Diameter: {d_2d:.2f}, 3D Diameter: {d_3d:.2f}"
        except:
            diameter_str = "Diameters not available"
        
        # Plot the histograms
        hist_2d, bin_edges_2d = np.histogram(areas_2d, bins=bins)
        hist_3d, bin_edges_3d = np.histogram(areas_3d, bins=bins)
        
        if Plot_log_level >= 2:
            print(f"\nPlotting image {i+1}:")
            print(f"2D histogram: {hist_2d}")
            print(f"3D histogram: {hist_3d}")
            print(f"Bin centers 2D: {bin_centers_2d}")
            print(f"Bin centers 3D: {bin_centers_3d}")
            
        # Normalize if requested - normalize each dataset individually
        if Frequency_percent_of_max:
            # Normalize 2D data to its own maximum
            if hist_2d.max() > 0:
                hist_2d = (hist_2d / max_frequency_2d) * 100
                if Plot_log_level >= 2:
                    print(f"Normalized 2D histogram: {hist_2d}")
                    
            # Normalize 3D data to its own maximum
            if hist_3d.max() > 0:
                hist_3d = (hist_3d / max_frequency_3d) * 100
                if Plot_log_level >= 2:
                    print(f"Normalized 3D histogram: {hist_3d}")

        # Calculate bin centers for bar plots
        bin_centers_2d = (bin_edges_2d[:-1] + bin_edges_2d[1:]) / 2
        bin_centers_3d = (bin_edges_3d[:-1] + bin_edges_3d[1:]) / 2
        
        # Plot histograms using bar chart for better clarity
        bar_width = (bins[1] - bins[0]) * 0.8  # Slightly narrower than bin width
        ax.bar(bin_centers_2d, hist_2d, width=bar_width, alpha=0.2, color='orange', 
               label='2D Area', align='center')
        ax.bar(bin_centers_3d, hist_3d, width=bar_width, alpha=0.2, color='green', 
               label='3D Area', align='center')
        
        # Add mean area lines
        mean_2d = np.mean(areas_2d)
        mean_3d = np.mean(areas_3d)
        ax.axvline(mean_2d, color='darkorange', linestyle='--', linewidth=2, label=f'Mean 2D: {mean_2d:.3f}')
        ax.axvline(mean_3d, color='darkgreen', linestyle='--', linewidth=2, label=f'Mean 3D: {mean_3d:.3f}')
        
        # Set axis limits and labels
        ax.set_xlim(
            min_area * 0.95,
            x_axis_limit if x_axis_limit is not None else max_area * x_axis_extension
        )
        
        y_max = y_axis_limit if y_axis_limit is not None else max_frequency * y_axis_extension
        ax.set_ylim(0, y_max)
        
        ax.set_xlabel('Cell Area (Non-Dimensional)')
        if Frequency_percent_of_max:
            ax.set_ylabel('Frequency (% of max)')
        else:
            ax.set_ylabel('Frequency (count)')
        ax.set_title(f'Image {i+1}: 2D vs 3D Reconstructed\nCell Area Distribution')
        
        # Add grid
        ax.grid(True, alpha=grid_alpha, linestyle='--')
        
        # Add legends with better positioning
        leg1 = ax.legend(loc='upper left', bbox_to_anchor=(0.02, 0.98))
        
        # Add cell count and area/diameter info in a separate box
        cell_count = len(areas_2d)
        box_text = f"Cell count: {cell_count}\n{diameter_str}"
        ax.text(0.02, 0.88, box_text, 
                transform=ax.transAxes, fontsize=10,
                bbox=dict(boxstyle='round', facecolor='white', alpha=0.7))

        # Save plots
        base_filename = f'area_comparison_{i+1:04d}'
        
        if save_png:
            png_path = os.path.join(png_dir, f'{base_filename}.png')
            plt.savefig(png_path, dpi=300, bbox_inches='tight')
        
        if save_svg:
            svg_path = os.path.join(svg_dir, f'{base_filename}.svg')
            plt.savefig(svg_path, format='svg', bbox_inches='tight')
        
        if show_plots:
            plt.show()
        
        plt.close(fig)
    
    # End of processing message
    print("\nFinished processing all images") if Plot_log_level >= 1 else None
    
    # Create video if requested
    if create_video and save_png:
        print("Creating video from plots...") if Plot_log_level >= 1 else None
        try:
            vm1.create_video_from_images(
                plot_image_folder=png_dir,
                video_output_dir=output_dir,
                fps=video_fps,
            )
            print(f"Video created in {output_dir}") if Plot_log_level >= 1 else None
        except Exception as e:
            print(f"Error creating video: {str(e)}") if Plot_log_level >= 0 else None
    
    return output_dir

# Example usage
if __name__ == "__main__":
    print("Running Diameter Distribution Comparison Plotter...")
    plot9_diameter_distribution_Srec_comparison(
        input_dir=r"C:\Users\obs\OneDrive\ETH\ETH_MSc\Masters Thesis\CIPS_variations\20250607_2240236\20250608_0303173\20250608_0303173\20250608_0409296\20250608_0643128\20250608_0645118\20250611_1634115",
        save_svg=False,
        save_png=True,
        show_plots=False,
        create_video=False,
        show_image_inset=True,
        Plot_log_level=1
    )
