import numpy as np
import matplotlib.pyplot as plt
import warnings
import glob
import os
import pandas as pd
import matplotlib.gridspec as gridspec
import skimage.io as sk_io
from matplotlib.colors import Normalize
import matplotlib as mpl
import Format_1 as F_1
import video_maker_1 as vm1
import matplotlib.cm as cm  # Add this import

# LaTeX settings
plt.rcParams['text.usetex'] = True
LATEX_FONT_SIZE = 16  # Global font size for LaTeX text
plt.rcParams['font.size'] = LATEX_FONT_SIZE
plt.rcParams['font.family'] = 'serif'

@F_1.ParameterLog(max_size=1024 * 10)  # 10KB
def plot10_distribution_histogram_comparison(
    # Input parameters
    input_dir,  # Format_1 requires input_dir
    SRec_df=None,  # if None a .pkl file has to be in the input_dir
    
    # Distribution parameters
    dist1_column='A_cell_distribution_nonDim2',      # Column name for first distribution
    dist2_column='A_cell_SRec_distribution_nonDim2', # Column name for second distribution
    dist1_label='2D Area',                           # Label for first distribution
    dist2_label='3D Area',                           # Label for second distribution
    dist1_color='orange',                            # Color for first distribution
    dist2_color='green',                            # Color for second distribution
    x_label='Cell Area (Non-Dimensional)',          # X-axis label
    plot_title_template='Image {}: {} vs {}\nDistribution Comparison', # Title template
    
    # Output and display parameters
    output_dir_manual="", 
    output_dir_comment="",
    save_svg=True,      # Save plots as SVG
    save_png=True,      # Save plots as PNG
    show_plots=False,   # Display plots during execution
    create_video=True,  # Create a video from the plot images
    video_fps=5,        # Frames per second for the video
    
    # Plot appearance parameters
    figure_width=12,            # Width of the figure in inches
    figure_height=8,            # Height of the figure in inches
    show_image_inset=True,      # Show flame image inset
    image_inset_size=0.4,        # Size of image inset as fraction of plot
    image_horizontal_position=0.76,  # Horizontal position of inset (0-1)
    image_vertical_position=0.68,    # Vertical position of inset (0-1)
    zoom_scale=1.3,              # Scale factor for zooming in on the spherical flame
    mask_alpha=0.4,               # Transparency of masks in the inset
    show_centroids=True,          # Show cell centroids in the inset
    centroid_size=7,            # Size of centroid markers
    centroid_alpha=0.6,          # Alpha value for centroid markers
    show_info_box=False,          # Show info box with cell count and diameters
    bin_count=50,                 # Number of histogram bins
    grid_alpha=0.2,               # Transparency of grid
    Plot_log_level=1,             # Logging verbosity
    x_axis_extension=1.1,         # Factor to extend x-axis beyond min/max area
    y_axis_extension=1.1,         # Factor to extend y-axis beyond max frequency
    x_axis_limit=None,            # Manual x-axis limit (overrides extension factor)
    y_axis_limit=None,            # Manual y-axis limit (overrides extension factor)
    Frequency_percent_of_max=True,  # If True, normalize frequency as percentage of max
    output_filename_template='Histogram_comparison_{:04d}',  # Template for output filenames
):
    """
    Creates comparative histograms of two distributions from a DataFrame.
    
    This function processes data from a DataFrame, creating histograms that compare
    two distributions for each row. It can optionally show an inset image of the
    source data with masks and centroids, and can compile the individual plots into a video.
    
    Parameters
    ----------
    input_dir : str
        Path to the directory containing the SRec_DataFrame.pkl file
        with data generated by Spherical_Reconstruction_1.
    SRec_df : pandas.DataFrame or None, optional
        A pre-loaded DataFrame containing the spherical reconstruction data.
        If provided, it overrides loading from the .pkl file in input_dir.
        If None, the function attempts to load SRec_DataFrame.pkl from input_dir.
        Defaults to None.
    output_dir_manual : str, optional
        If provided, specifies the exact output directory path for the plots/video.
        Overrides the default naming convention. Defaults to "".
    output_dir_comment : str, optional
        A comment to append to the default output directory name. Defaults to "".
    save_svg : bool, optional
        If True, saves plots in SVG format. Defaults to True.
    save_png : bool, optional
        If True, saves plots in PNG format. Defaults to True.
    show_plots : bool, optional
        If True, displays plots during execution. Defaults to False.
    create_video : bool, optional
        If True, creates a video from the generated plot images using video_maker_1.
        Defaults to True.
    video_fps : int, optional
        Frames per second for the video if create_video is True. Defaults to 5.
    figure_width : float, optional
        Width of the figure in inches. Defaults to 12.
    figure_height : float, optional
        Height of the figure in inches. Defaults to 9.
    show_image_inset : bool, optional
        If True, shows an inset of the flame image with masks. Defaults to True.
    image_inset_size : float, optional
        Size of the image inset as a fraction of the plot. Defaults to 0.35.
    image_horizontal_position : float, optional
        Horizontal position of the image inset (0-1, where 1 is far right). Defaults to 0.65.
    image_vertical_position : float, optional
        Vertical position of the image inset (0-1, where 1 is top). Defaults to 0.75.
    zoom_scale : float, optional
        Scale factor for zooming in on the spherical flame in the image inset. Defaults to 1.5.
    mask_alpha : float, optional
        Transparency of masks in the inset image. Defaults to 0.3.
    show_centroids : bool, optional
        If True, shows cell centroids in the image inset. Defaults to True.
    centroid_size : int, optional
        Size of the centroid markers in the image inset. Defaults to 10.
    centroid_alpha : float, optional
        Alpha value for the centroid markers in the image inset. Defaults to 0.7.
    show_info_box : bool, optional
        If True, shows the info box with cell count and diameter information on the plot. Defaults to True.
    bin_count : int, optional
        Number of bins for the diameter distribution histogram. Defaults to 30.
    grid_alpha : float, optional
        Transparency of the grid in the plot. Defaults to 0.2.
    Plot_log_level : int, optional
        Controls the verbosity of logging. Defaults to 1.
    x_axis_extension : float, optional
        Factor to extend the x-axis range beyond the min and max area values.
        Defaults to 1.1 (10% extension).
    y_axis_extension : float, optional
        Factor to extend the y-axis range beyond the max frequency value.
        Defaults to 1.1 (10% extension).
    x_axis_limit : tuple of float, optional
        Manual limits for the x-axis as (min, max). Overrides x_axis_extension if provided.
    y_axis_limit : tuple of float, optional
        Manual limits for the y-axis as (min, max). Overrides y_axis_extension if provided.
    Frequency_percent_of_max : bool, optional
        If True, normalizes frequency as percentage of maximum frequency across all images.
        Default is False.
    output_filename_template : str, optional
        Template for output filenames. Must contain exactly one placeholder '{}' 
        for the image index. Default is 'Histogram_comparison_{:04d}'.
    
    Returns
    -------
    output_dir : str
        The path to the directory where the output plots and folders are saved.
    
    Notes
    -----
    The function creates separate directories for PNG and SVG outputs within the main output directory.
    It compares original cell diameter distributions with those after spherical reconstruction.
    """
    # Suppress MatplotlibDeprecationWarning if log level is not >= 2
    if Plot_log_level < 2:
        warnings.filterwarnings('ignore', category=mpl.MatplotlibDeprecationWarning)

    #################################################### I/O
    output_dir = F_1.F_out_dir(input_dir, __file__, output_dir_comment=output_dir_comment, 
                            output_dir_manual=output_dir_manual)  # Format_1 required definition of output directory

    # Set normalization option
    normalize_to_percent = True  # Move this declaration up here

    # Create subdirectories for PNG and SVG outputs if needed
    if save_png:
        png_dir = os.path.join(output_dir, "png_plots")
        os.makedirs(png_dir, exist_ok=True)
        print(f"PNG plots will be saved to: {png_dir}") if Plot_log_level >= 1 else None
    
    if save_svg:
        svg_dir = os.path.join(output_dir, "svg_plots")
        os.makedirs(svg_dir, exist_ok=True)
        print(f"SVG plots will be saved to: {svg_dir}") if Plot_log_level >= 1 else None

    #################################################### Load data
    if SRec_df is None:
        # Look for SRec_DataFrame.pkl file
        srec_file_path = os.path.join(input_dir, "SRec_DataFrame.pkl")
        if not os.path.exists(srec_file_path):
            # If not found, try to find any .pkl file
            pkl_files = glob.glob(os.path.join(input_dir, "*.pkl"))
            if pkl_files:
                srec_file_path = pkl_files[0]
            else:
                raise FileNotFoundError(f"No SRec_DataFrame.pkl or other .pkl files found in {input_dir}")
        
        print(f"Loading spherical reconstruction data from: {srec_file_path}") if Plot_log_level >= 1 else None
        SRec_df = pd.read_pickle(srec_file_path)
    else:
        print("Using provided SRec DataFrame") if Plot_log_level >= 1 else None

    # Verify the DataFrame has the required columns
    required_columns = ['d_cell_distribution_nonDim', 'd_cell_SRec_distribution_nonDim', 
                         'image_file_path', 'masks', 'centroid_xIm_distribution_px', 
                         'centroid_yIm_distribution_px', 'A_cell_distribution_nonDim2', 
                         'A_cell_SRec_distribution_nonDim2']
    
    for col in required_columns:
        if col not in SRec_df.columns:
            print(f"Warning: Column '{col}' not found in the DataFrame. Some functionality may be limited.")

    #################################################### Clean data
    # Clean data once after loading
    print("Cleaning data...") if Plot_log_level >= 1 else None
    
    # Create new columns for cleaned data with dynamic names
    dist1_clean_column = f'{dist1_column}_clean'
    dist2_clean_column = f'{dist2_column}_clean'
    
    SRec_df[dist1_clean_column] = SRec_df[dist1_column].apply(
        lambda x: x[~np.isnan(x)] if x is not None else np.array([])
    )
    SRec_df[dist2_clean_column] = SRec_df[dist2_column].apply(
        lambda x: x[~np.isnan(x)] if x is not None else np.array([])
    )
    
    # Remove rows where either cleaned array is empty
    valid_rows = (SRec_df[dist1_clean_column].apply(len) > 0) & \
                 (SRec_df[dist2_clean_column].apply(len) > 0)
    SRec_df = SRec_df[valid_rows].reset_index(drop=True)

    if len(SRec_df) == 0:
        print("Error: No valid data found after cleaning") if Plot_log_level >= 0 else None
        return output_dir

    #################################################### Calculate global statistics
    # Number of rows in the DataFrame
    N_images = len(SRec_df)
    
    # Concatenate all valid values
    all_dist1 = np.concatenate(SRec_df[dist1_clean_column].values)
    all_dist2 = np.concatenate(SRec_df[dist2_clean_column].values)
    
    # Calculate global min/max
    max_val = max(np.max(all_dist1), np.max(all_dist2))
    min_val = min(np.min(all_dist1), np.min(all_dist2))
    
    # Calculate global max frequency
    max_frequency_global = 0
    for dist1, dist2 in zip(SRec_df[dist1_clean_column], 
                                 SRec_df[dist2_clean_column]):
        hist_1, _ = np.histogram(dist1, bins=bin_count)
        hist_2, _ = np.histogram(dist2, bins=bin_count)
        max_frequency_global = max(max_frequency_global, np.max(hist_1), np.max(hist_2))

    print(f"Processing {N_images} images with area range: {min_val:.2f} to {max_val:.2f}") if Plot_log_level >= 1 else None
    print(f"Global maximum frequency: {max_frequency_global}") if Plot_log_level >= 1 else None

    #################################################### Plotting
    # Process each image
    print(f"\nPlotting area distributions:")
    for i in range(N_images):
        print(f"\rProcessing image {i+1}/{N_images}", end='', flush=True) if Plot_log_level >= 1 else None
        
        # Create figure with specified size
        fig = plt.figure(figsize=(figure_width, figure_height))
        ax = fig.add_subplot(111)
        
        # Get the cleaned distributions
        dist1_data = SRec_df.iloc[i][dist1_clean_column]
        dist2_data = SRec_df.iloc[i][dist2_clean_column]
        
        # Create bins for this specific image
        bins = np.linspace(min_val, max_val, bin_count + 1)
        
        # Calculate the histograms
        hist_1, bin_edges_1 = np.histogram(dist1_data, bins=bins)
        hist_2, bin_edges_2 = np.histogram(dist2_data, bins=bins)
        
        # Apply normalization based on user preference
        if Frequency_percent_of_max:
            # Normalize to percentage of total count (instead of % of max)
            total_count_1 = len(dist1_data)
            total_count_2 = len(dist2_data)
            
            # Calculate weights for normalization to percentage of total
            weights_1 = np.ones_like(dist1_data) * (100.0 / total_count_1)
            weights_2 = np.ones_like(dist2_data) * (100.0 / total_count_2)
            
            y_label = r'Frequency (\% of total)'
            # Set y-axis limit based on user input or extension
            y_max = y_axis_limit if y_axis_limit is not None else max_frequency_global * y_axis_extension
            
            # Plot histograms with normalized values and black edges
            ax.hist(dist1_data, bins=bins, alpha=0.6, color=dist1_color, 
                   label=dist1_label, weights=weights_1, edgecolor='black', linewidth=0.5)
            ax.hist(dist2_data, bins=bins, alpha=0.6, color=dist2_color, 
                   label=dist2_label, weights=weights_2, edgecolor='black', linewidth=0.5)
        else:
            # Use raw counts
            y_label = r'Frequency (count)'
            # Set y-axis limit based on user input or global max with extension
            y_max = y_axis_limit if y_axis_limit is not None else max_frequency_global * y_axis_extension
            
            # Plot histograms with raw counts and black edges
            ax.hist(dist1_data, bins=bins, alpha=0.6, color=dist1_color, 
                   label=dist1_label, edgecolor='black', linewidth=0.5)
            ax.hist(dist2_data, bins=bins, alpha=0.6, color=dist2_color, 
                   label=dist2_label, edgecolor='black', linewidth=0.5)
        
        # Add mean area lines
        mean_1 = np.mean(dist1_data)
        mean_2 = np.mean(dist2_data)
        ax.axvline(mean_1, color=dist1_color, linestyle='--', linewidth=2, 
                  label=f'Mean {dist1_label}: {mean_1:.3f}')
        ax.axvline(mean_2, color=dist2_color, linestyle='--', linewidth=2, 
                  label=f'Mean {dist2_label}: {mean_2:.3f}')
        
        # Set axis limits and labels
        x_min = min_val * 0.95
        x_max = x_axis_limit if x_axis_limit is not None else max_val * x_axis_extension
        ax.set_xlim(x_min, x_max)
        ax.set_ylim(0, y_max)
        
        ax.set_xlabel(x_label)
        ax.set_ylabel(y_label)
        ax.set_title(plot_title_template.format(i+1, dist1_label, dist2_label))
        
        # Add grid
        ax.grid(True, alpha=grid_alpha, linestyle='--')
        
        # Add legends centered at the top of the plot
        ax.legend(loc='upper center', bbox_to_anchor=(0.5, 0.98))

        # Add image inset if requested
        if show_image_inset:
            try:
                # Calculate position based on new parameters
                inset_width = image_inset_size
                inset_height = image_inset_size
                inset_left = image_horizontal_position - (inset_width / 2)
                inset_bottom = image_vertical_position - (inset_height / 2)
                
                # Create inset axes
                ax_inset = fig.add_axes([inset_left, inset_bottom, inset_width, inset_height])
                
                # Load and display image
                image_path = SRec_df.iloc[i]['image_file_path']
                image = sk_io.imread(image_path)
                
                # Make white parts transparent
                if len(image.shape) == 2:  # Grayscale image
                    # Create RGBA image
                    rgba_image = np.zeros((*image.shape, 4), dtype=np.uint8)
                    rgba_image[..., :3] = np.stack([image]*3, axis=-1)
                    rgba_image[..., 3] = np.where(image == 255, 0, 255)
                    image = rgba_image
                elif len(image.shape) == 3:  # RGB image
                    # Create RGBA image
                    rgba_image = np.zeros((*image.shape[:2], 4), dtype=np.uint8)
                    rgba_image[..., :3] = image
                    is_white = np.all(image == 255, axis=-1)
                    rgba_image[..., 3] = np.where(is_white, 0, 255)
                    image = rgba_image

                masks = SRec_df.iloc[i]['masks']
                
                # Calculate zoom region to focus on the spherical flame
                img_height, img_width = image.shape[:2]
                center_x, center_y = img_width // 2, img_height // 2
                D_SF_px = SRec_df.iloc[i]['D_SF_px']
                zoom_half_size = int(D_SF_px * zoom_scale / 2)
                
                # Ensure zoom region is within image bounds
                left = max(0, center_x - zoom_half_size)
                right = min(img_width, center_x + zoom_half_size)
                top = max(0, center_y - zoom_half_size)
                bottom = min(img_height, center_y + zoom_half_size)
                
                # Extract and display the zoomed region
                image_zoomed = image[top:bottom, left:right]
                ax_inset.imshow(image_zoomed)
                
                # Create a masked array for the masks in the zoomed region
                masks_zoomed = masks[top:bottom, left:right]
                masked_data = np.ma.masked_where(masks_zoomed == 0, masks_zoomed % 10)
                
                # Use older syntax for colormap
                cmap = cm.get_cmap('tab10', 10)
                ax_inset.imshow(masked_data, cmap=cmap, alpha=mask_alpha)

                # Show centroids if requested
                if show_centroids and 'centroid_xIm_distribution_px' in SRec_df.columns:
                    centroids_x = SRec_df.iloc[i]['centroid_xIm_distribution_px']
                    centroids_y = SRec_df.iloc[i]['centroid_yIm_distribution_px']
                    if len(centroids_x) > 0 and len(centroids_y) > 0:
                        # Adjust centroid coordinates for zoomed view
                        valid_centroids = [(x, y) for x, y in zip(centroids_x, centroids_y)
                                         if left <= x <= right and top <= y <= bottom]
                        if valid_centroids:
                            x_coords, y_coords = zip(*valid_centroids)
                            ax_inset.scatter(
                                [x - left for x in x_coords],
                                [y - top for y in y_coords],
                                c='red', s=centroid_size, alpha=centroid_alpha
                            )

                # Turn off axes for the inset
                ax_inset.axis('off')
                
                # Add a thin border around the inset
                for spine in ax_inset.spines.values():
                    spine.set_visible(True)
                    spine.set_color('black')
                    spine.set_linewidth(0.5)
                
            except Exception as e:
                print(f"\nWarning: Could not display image inset for image {i+1}: {str(e)}") if Plot_log_level >= 1 else None
        
        # Add cell count and diameter info in a separate box
        if show_info_box:
            try:
                d_2d = np.mean(SRec_df.iloc[i]['d_cell_distribution_nonDim'])
                d_3d = np.mean(SRec_df.iloc[i]['d_cell_SRec_distribution_nonDim'])
                diameter_str = f"2D Diameter: {d_2d:.2f}\n3D Diameter: {d_3d:.2f}"
                cell_count = len(dist1_data)
                box_text = f"Cell count: {cell_count}\n{diameter_str}"
                ax.text(0.02, 0.88, box_text, 
                       transform=ax.transAxes, fontsize=10,
                       bbox=dict(boxstyle='round', facecolor='white', alpha=0.7))
            except Exception as e:
                print(f"\nWarning: Could not add diameter info: {str(e)}") if Plot_log_level >= 1 else None

        # Save plots with configurable filename
        base_filename = output_filename_template.format(i+1)
        
        if save_png:
            png_path = os.path.join(png_dir, f'{base_filename}.png')
            plt.savefig(png_path, dpi=300, bbox_inches='tight')
        
        if save_svg:
            svg_path = os.path.join(svg_dir, f'{base_filename}.svg')
            plt.savefig(svg_path, format='svg', bbox_inches='tight')
        
        if show_plots:
            plt.show()
        
        plt.close(fig)
    
    # End of processing message
    print("\nFinished processing all images") if Plot_log_level >= 1 else None
    
    # Create video if requested
    if create_video and save_png:
        print("Creating video from plots...") if Plot_log_level >= 1 else None
        try:
            vm1.create_video_from_images(
                plot_image_folder=png_dir,
                video_output_dir=output_dir,
                fps=video_fps,
            )
            print(f"Video created in {output_dir}") if Plot_log_level >= 1 else None
        except Exception as e:
            print(f"Error creating video: {str(e)}") if Plot_log_level >= 0 else None
    
    return output_dir

# Example usage
if __name__ == "__main__":
    print("Running Generic Distribution Comparison Plotter...")
    plot10_distribution_histogram_comparison(
        input_dir=r"C:\Users\obs\OneDrive\ETH\ETH_MSc\Masters Thesis\CIPS_variations\20250607_2240236\20250608_0303173\20250608_0303173\20250608_0409296\20250608_0643128\20250608_0645118\20250612_1349113",
        dist1_column='d_cell_distribution_nonDim',
        dist2_column='d_cell_SRec_distribution_nonDim',
        dist1_label='2D',
        dist2_label='3D',
        x_label=r'Cell Diameter / $\delta_T$',
        output_filename_template='Diameter_2Dvs3D_histogram_{:04d}',  # Custom filename template
        save_svg=False,
        save_png=True,
        show_plots=False,
        create_video=True,
        show_image_inset=True,
        Plot_log_level=1
    )
    plot10_distribution_histogram_comparison(
        input_dir=r"C:\Users\obs\OneDrive\ETH\ETH_MSc\Masters Thesis\CIPS_variations\20250607_2240236\20250608_0303173\20250608_0303173\20250608_0409296\20250608_0643128\20250608_0645118\20250612_1349113",
        dist1_column='A_cell_distribution_nonDim2',
        dist2_column='A_cell_SRec_distribution_nonDim2',
        dist1_label='2D',
        dist2_label='3D',
        x_label=r'Cell Area / $\delta_T^2$',
        output_filename_template='Area_2Dvs3D_histogram_{:04d}',  # Custom filename template
        save_svg=False,
        save_png=True,
        show_plots=False,
        create_video=True,
        show_image_inset=True,
        Plot_log_level=1
    )